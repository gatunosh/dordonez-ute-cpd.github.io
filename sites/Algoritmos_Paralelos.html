<!DOCTYPE HTML>
<!--
	Binary by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<!--Poner el titulo de la clase-->
		<title>Algoritmos Paralelos</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="../assets/css/main.css" />
	</head>
	<body>

		<!-- Header -->
		<header id="header">
			<a href="../index.html" class="logo"
			  ><strong>Computación Paralela y Distribuida</strong></a
			>
		  </header>


		<!-- Main -->
			<section id="main">
				<div class="inner">
					<!--Usar el siguiente div para poner imagenes en el doc-->
					<div class="image fit">
						<img src="file:///C|/Users/User/Documents/GitHub/dordonez-ute-cpd.github.io/images/paralel_principal.jpg" height="350"alt="" />
					</div>
					<!--Poner toda la informacion de la clase-->
					<header>
						<!--Poner el titulo de la clase-->
						<h1>Algoritmos Paralelos</h1>
						<!--Poner fecha de la clase-->
						<p class="info">07 del Mayo del 2020</p>
					</header>
					<!--Ingresar toda la informacion necesaria usando las diferentes etiquetas-->
                    <ol>
					<li><a href="Algoritmos_Paralelos.html#two">¿Qué es Computación Paralela?</a></li>
					
                    <li><a href="Algoritmos_Paralelos#thirteen">Modelos de Algoritmos Paralelos</a></li>
					<li><a href="Algoritmos_Paralelos.html#four">Ventajas y desventajas</a></li>
									
					
									
				</ol>
<section id="two" class="wrapper style1 alt">
          
				<center><b><h2>¿Qué es computación paralela?</h2></b></center>
				<ul class="checklist">
					<p>En el sentido más simple, la computación paralela es el uso simultáneo de múltiples recursos computacionales para resolver
						un problema computacional:
					</p>
					<li>Un problema se divide en partes discretas que se pueden resolver simultáneamente</li>
					<li>Cada parte se descompone en una serie de instrucciones</li>
					<li>Las instrucciones de cada parte se ejecutan simultáneamente en diferentes procesadores</li>
					<li>Se emplea un mecanismo global de control/coordinación</li>
				</ul>
                </section>

	<section id="thirteen" class="wrapper style1 alt">
		<center><h2>Modelos de Algoritmos Paralelos</h2></center>
		<div class="inner">
			<div class="spotlight">
				<div class="contentmo">
					<h3>Modelo de datos en paralelo.</h3>
					<p class="pjustify">
						Es uno de los modelos más simples. Las tareas son mapeadas en forma estática o semi-estática a los procesadores y cada tarea ejecuta las mismas operaciones sobre diferentes conjuntos de datos. 
					<br>
					</p>
				</div>
				<div class="contentmo">
					<center><img src="file:///C|/Users/User/Documents/GitHub/dordonez-ute-cpd.github.io/images/modelo_dato_paralelo.png" height="400" width="500"/></center>
				</div>
			</div>
			<div class="spotlight">
				<div class="contentmo">
					<h3>Modelo de grafo de tareas.</h3>
					<p class="pjustify">
En todos los algoritmos paralelos, el procesamiento puede ser visto como un grafo de dependencias de tareas. 
En este modelo, se parte del grafo de dependencias para utilizar las interrelaciones de las mismas en la decisión de la localidad de procesos y datos y de esta manera reducir los costos de interacción.
Es típicamente utilizado para resolver problemas en donde el volumen de datos asociado con las tareas es mayor que el tamaño del cómputo asociado a las mismas. 
					</p>
                   <center> <img src="file:///C|/Users/User/Documents/GitHub/dordonez-ute-cpd.github.io/images/paraleo_grafo.png"/></center>
					<h4>Productor consumidor o modelo de "Pipeline" </h4>
					<p>
						El pipeline proviene de la idea de que en una tubería no es necesario esperar a que todo el agua dentro salga,
						para que pueda entrar más.
						Los procesadores modernos tienen un 'pipeline' que separa las instrucciones en varias etapas, donde cada etapa
						corresponde a una acción diferente que necesita la salida de la anterior.
					</p>
				</div>
				<div class="contentmo">
					<p>
						<b>Ejemplo:</b> Un pipeline de 5 etapas: fetch (buscar la instrucción), decode (decodificarla), execute (ejecutarla),
						write (escribir en memoria el resultado de la operación).
					</p>
					<img src="file:///C|/Users/User/Documents/GitHub/dordonez-ute-cpd.github.io/images/pipelining.png">
					<p>
						En el gráfico anterior se observa el procesamiento de dos instrucciones sin pipeline, tomando un tiempo de 8 ciclos,
						y con pipeline reduciendo este tiempo a solo 5 ciclos.
					</p>
				</div>
			</div>
			<div class="spotlight">
				<div class="contentmo">
					<br>
					<h3>Modelo de "Workpool"</h3>
					<p class="pjustify">
El modelo work pool o task pool está caracterizado por el mapeo dinámico de tareas a procesadores para el balance de carga en donde cada tarea puede ser ejecutada potencialmente por cualquier procesador. No hay un mapeo preestablecido de tareas a procesadores. El mapeo puede ser centralizado o descentralizado.
Normalmente se utiliza este modelo cuando el volumen de datos que debe procesar cada tarea es menor que el procesamiento que debe llevar a cabo la misma. Esto se debe a que las tareas pueden ser reubicadas dinámicamente sin costos altos de interacción de datos (overhead). 

					</p>
					<center><img src="file:///C|/Users/User/Documents/GitHub/dordonez-ute-cpd.github.io/images/paralelo_grupo_trabajo.png" width="465" height="257"></center>
					
				</div>
				<div class="contentmo">
					<h3>Modelo maestro esclavo</h3>
                   <center> <img src="file:///C|/Users/User/Documents/GitHub/dordonez-ute-cpd.github.io/images/paralelo_maestro_esclavo.png"></center>
					<p class="pjustify">
En este modelo uno o más procesos distribuyen trabajo (master) entre los workers. El o los procesos master saben que tienen que dar trabajo y los procesos workers saben que necesitan obtener trabajo del master.
La granularidad de las tareas en este modelo debe ser elegida cuidadosamente, teniendo en cuenta que el costo de realizar cómputo debe dominar al costo de la transferencia de trabajo y de sincronización, pero sin generar tareas demasiado grandes que puedan afectar el balance de carga. 
					</p>
					
				</div>
			</div>
		</div>
        <div class="spotlight">
	  <div class="contentmo">
					<br>
					<h3>Modelo Híbrido"</h3>
		<p class="pjustify">
En algunos casos, más de un modelo puede ser aplicado al problema que se quiere resolver, de esta manera se obtiene un modelo híbrido.
Un modelo híbrido puede estar compuesto tanto por múltiples modelos aplicados jerárquicamente o múltiples modelos aplicados secuencialmente a diferentes fases del algoritmo paralelo. 


		  </p>
				</div>
	</section>


<section id="four" class="wrapper style1 alt">
		<div class="inner split">
			<section>
				<h2>Ventajas</h2>
				<ul>
					<li>Resuelve problemas que no se podrían realizar en una sola CPU</li>
					<li>Resuelve problemas que no se pueden resolver en un tiempo razonable</li>
					<li>Permite ejecutar problemas de un orden y complejidad mayor</li>
					<li>Permite ejecutar código de manera más rápida (aceleración)</li>
					<li>Permite ejecutar en general más problemas</li>
					<li>Obtención de resultados en menos tiempo</li>
					<li>Permite la ejecución de varias instrucciones en simultáneo</li>
					<li>Permite dividir una tarea en partes independientes</li>
				</ul>
			</section>
			<section>
				<h2>Desventajas</h2>
				<ul>
					<li>Mayor consumo de energía</li>
					<li>Mayor dificultad a la hora de escribir programas</li>
					<li>Dificultad para lograr una buena sincronización y comunicación entre las tareas</li>
					<li>Retardos ocasionados por comunicación ente tareas</li>
					<li>Número de componentes usados es directamente proporcional a los fallos potenciales</li>
					<li>Condiciones de carrera</li>
					<li>Múltiples procesos se encuentran en condición de carrera si el resultado de los mismos depende del orden de su llegada.</li>
					<li>Si los procesos que están en condición de carrera no son correctamente sincronizados, puede producirse una corrupción de datos.</li>
				</ul>
			</section>
	</div></section>




                    
                    
                    
                    
                    
                    
					
				</div>
			</section>

		<!-- Footer -->
			<footer id="footer">
				<p>
					Trabajo del curso de Computación Paralela y Distribuida <br />
					<small>Universidad UTE</small>
				  </p>
			
				  <div class="copyright">
					Design: <a href="https://templated.co">TEMPLATED</a>
				  </div>
			</footer>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/skel.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>